---
description: Enforce non-negotiable standards for acceptance tests in the Digital Kudos Wall project using the Four-Layer Architecture and test quality guidelines.
globs:
  - "digital-kudos-wall-system-tests/src/acceptance/**/*"
alwaysApply: false
---

# üß™ Standard Operating Procedure: Acceptance Tests

**Status:** Mandatory  
**Version:** 1.0

## üìå Purpose

This SOP enforces test quality, structure, and maintainability using Dave Farley‚Äôs Four-Layer Model. It applies to all acceptance tests in the `digital-kudos-wall-system-tests` repository.

---

## üß≠ Architecture: Dave Farley's Four-Layer Model

### 1. Business Layer (Features)

- MUST use Gherkin syntax
- MUST focus on **business behavior**, not implementation
- MUST use ubiquitous domain language
- MUST live in: `/src/acceptance/features`
- Example: `src/acceptance/features/account_registration.feature`

**‚úÖ Example:**

```gherkin
   Feature: User Registration
     As a new user
     I want to register for an account
     So that I can access the kudos wall

     Scenario: Successful registration
       Given I am on the registration page
       When I register with valid details:
         | name     | email           | password     |
         | John Doe | john@example.com| SecurePass1! |
       Then I should be redirected to the login page
       And I should receive a confirmation email
```

### 2. Test Layer (Step Definitions)

- MUST reside in: `/src/acceptance/step_definitions`
- MUST only use DSL methods (no drivers directly)
- MUST map Gherkin steps to DSL calls
- MUST orchestrate steps, not execute logic
- Example: `src/acceptance/step_definitions/account_registration.steps.ts`

**‚úÖ Example:**

```typescript
import { Given, When, Then } from "@cucumber/cucumber";
import { RegistrationDSL } from "../dsl/registration.dsl";

Given("I am on the registration page", async function () {
  await this.registrationDSL.navigateToRegistration();
});

When("I register with valid details:", async function (dataTable) {
  const details = dataTable.hashes()[0];
  await this.registrationDSL.registerUser(details);
});
```

### 3. DSL Layer (Domain-Specific Language)

- MUST live in: `/src/acceptance/dsl`
- MUST abstract implementation via driver layer
- MUST provide business-relevant reusable methods
- MUST abstract away technical implementation details
- MUST be reusable across multiple test scenarios
- Example: `src/acceptance/dsl/account_registration_dsl.ts`

**‚úÖ Example:**

```typescript
export class RegistrationDSL {
  constructor(private registrationPage: AccountRegistrationPage) {}

  async navigateToRegistration(): Promise<void> {
    await this.registrationPage.navigate();
  }

  async registerUser(details: RegistrationDetails): Promise<void> {
    await this.registrationPage.registerUser(details);
  }

  async verifyRegistrationSuccess(): Promise<boolean> {
    return this.registrationPage.isRegistrationSuccessful();
  }
}
```

### 4. Driver Layer

- MUST be stored in: `/src/acceptance/drivers`
- MUST isolate all system interactions
- MUST use Page Object pattern for UI
- MUST define clear interfaces for each driver
- MUST implement tech-specific logic behind interfaces
- Example Interface and Implementation: `src/acceptance/drivers/account_registration_driver.interface.ts` and `src/acceptance/drivers/web/account_registration_web_driver.ts`

**‚úÖ Example:**

```typescript
export interface AccountRegistrationDriver {
  checkServiceHealth(): Promise<void>;
  createTestUser(details: RegistrationDetails): Promise<void>;
  register(details: RegistrationDetails): Promise<RegistrationResult>;
  verifyConfirmationEmail(email: string): Promise<boolean>;
  cleanup(): Promise<void>;
}
```

```typescript
export class AccountRegistrationWebDriver implements AccountRegistrationDriver {
  private readonly accountRegistrationPage: AccountRegistrationPage;

  constructor(private readonly page: Page) {
    this.accountRegistrationPage = PageFactory.createAccountRegistrationPage(page);
  }

  async checkServiceHealth(): Promise<void> {
    await this.accountRegistrationPage.navigate();
  }

  async createTestUser(details: RegistrationDetails): Promise<void> {
    const response = await this.page.request.post(`${CONFIG.apiUrl}/test-support/users`, {
      data: {
        name: details.name,
        email: details.email,
        password: details.password,
      },
    });

    if (!response.ok()) {
      throw new Error(
        `Failed to create test user via API. Status: ${response.status()}, Body: ${await response.text()}`
      );
    }
  }

  async register(details: RegistrationDetails): Promise<RegistrationResult> {
    await this.accountRegistrationPage.navigate();
    await this.accountRegistrationPage.registerUser(details);
    const errorMessage = await this.accountRegistrationPage.getErrorMessage();

    if (errorMessage) {
      return {
        success: false,
        errorMessage,
      };
    }

    const isSuccessful = await this.accountRegistrationPage.isRegistrationSuccessful();

    if (!isSuccessful) {
      const failureMessage = await this.accountRegistrationPage.getErrorMessage();
      return {
        success: false,
        errorMessage: failureMessage || "Registration failed",
      };
    }

    return {
      success: true,
      errorMessage: undefined,
    };
  }

  async verifyConfirmationEmail(email: string): Promise<boolean> {
    return this.accountRegistrationPage.isConfirmationEmailSentTo(email);
  }

  async cleanup(): Promise<void> {
    try {
      const response = await this.page.request.delete(`${CONFIG.apiUrl}/test-support/cleanup`);

      if (!response.ok()) {
      }
    } catch (error) {
      console.warn("Failed to cleanup test data:", error);
    }
  }
}
```

---

## üîå External System Stubbing Strategy

**Reference:** [Modern Test Pyramid - System Level](https://journal.optivem.com/p/modern-test-pyramid-system-level)

### Core Principle

Acceptance Tests verify System behavior in **isolation from External Systems**, enabling us to test any functional Acceptance Criteria while maintaining fast, reliable tests.

### When to Stub External Systems

**External Systems** (MUST be stubbed):

- **Email Services** (SendGrid, Mailgun, SMTP providers)
- **Payment Gateways** (Stripe, PayPal, Square)
- **Third-party APIs** (Social login providers, Geocoding services, Weather APIs)
- **SMS/Notification Services** (Twilio, Pusher)
- **External Authentication** (OAuth providers, SAML identity providers)

**Infrastructure Dependencies** (Use REAL instances):

- **Databases** - Use real test database instances
- **File Storage** (AWS S3, Azure Blob) - Use real test buckets/containers
- **Message Queues** (RabbitMQ, AWS SQS) - Use real test queues
- **Caching** (Redis) - Use real test Redis instances
- **Internal APIs** - Use real internal service instances

**Key Principle**: Acceptance Tests verify system behavior using real infrastructure but with stubbed external dependencies. This provides maximum realism while maintaining test reliability and avoiding external costs/dependencies.

### Implementation Strategy

#### 1. Environment-Based Configuration

Configure the system to use stubs in test environments:

```typescript
// In main application bootstrap (e.g., index.ts)
let emailService: EmailService;
if (process.env.NODE_ENV === "test") {
  emailService = TestEmailService.getInstance();
} else {
  emailService = new ProductionEmailService();
}
```

#### 2. Test Double Implementation

Create test doubles that implement the same interface as production services:

```typescript
// Production interface
export interface EmailService {
  sendConfirmationEmail(email: string): Promise<void>;
}

// Test double implementation
export class TestEmailService implements EmailService {
  private static instance: TestEmailService;
  private sentEmails: string[] = [];

  static getInstance(): TestEmailService {
    if (!TestEmailService.instance) {
      TestEmailService.instance = new TestEmailService();
    }
    return TestEmailService.instance;
  }

  async sendConfirmationEmail(email: string): Promise<void> {
    this.sentEmails.push(email);
  }

  getSentEmails(): string[] {
    return [...this.sentEmails];
  }

  wasEmailSentTo(email: string): boolean {
    return this.sentEmails.includes(email);
  }

  reset(): void {
    this.sentEmails = [];
  }
}
```

#### 3. Test Support API

Provide endpoints to verify stub behavior:

```typescript
// Test support controller
async verifyEmailSent(req: Request, res: Response): Promise<Response> {
  const { email } = req.query;
  const emailService = TestEmailService.getInstance();
  const wasEmailSent = emailService.wasEmailSentTo(email);
  return res.status(200).json({ sent: wasEmailSent });
}

// Test support routes
testSupportRouter.get("/verify-email", (req, res) =>
  testSupportController.verifyEmailSent(req, res)
);
```

#### 4. Driver Layer Verification

Verify external system interactions through test support APIs:

```typescript
export class AccountRegistrationWebDriver implements AccountRegistrationDriver {
  async verifyConfirmationEmail(email: string): Promise<boolean> {
    const response = await this.page.request.get(`${CONFIG.apiUrl}/test-support/verify-email`, { params: { email } });

    if (!response.ok()) {
      return false;
    }

    const { sent } = await response.json();
    return sent;
  }
}
```

#### 5. Cleanup Strategy

Reset stub state between test scenarios:

```typescript
// In test support cleanup
async cleanup(req: Request, res: Response): Promise<Response> {
  await this.cleanupTestDataUseCase.execute();
  // Reset all external system stubs
  TestEmailService.getInstance().reset();
  TestPaymentService.getInstance().reset();
  // ... other stubs

  return res.status(200).json({ message: "Test data cleaned up successfully" });
}
```

### Benefits of This Approach

1. **Fast Execution**: No network calls to external services
2. **Reliable Tests**: No flaky failures due to external service issues
3. **Comprehensive Coverage**: Can test error scenarios that are hard to reproduce with real services
4. **Cost Effective**: No charges from external services during testing
5. **Parallel Execution**: Tests can run in parallel without conflicts

### Anti-Patterns to Avoid

‚ùå **DON'T** verify external system behavior through UI elements:

```typescript
// BAD: Checking for transient UI messages
async isConfirmationEmailSent(): Promise<boolean> {
  const message = await this.page.getByTestId("email-sent-message");
  return message.isVisible();
}
```

‚ùå **DON'T** mix stub verification with production interface:

```typescript
// BAD: Adding test methods to production interface
interface EmailService {
  sendConfirmationEmail(email: string): Promise<void>;
  getSentEmails?(): string[]; // This pollutes the production interface
}
```

‚ùå **DON'T** use real external services in acceptance tests:

```typescript
// BAD: Using real email service in tests
const emailService = new SendGridEmailService(apiKey);
```

### Validation Checklist for External System Stubbing

‚úÖ External services are stubbed at application boundary  
‚úÖ Stubs implement the same interface as production services  
‚úÖ Test support APIs provide verification capabilities  
‚úÖ Stub state is reset between test scenarios  
‚úÖ Environment-based configuration switches between stubs and real services  
‚úÖ No network calls to external services during acceptance tests  
‚úÖ Tests verify business behavior, not implementation details

---

## Page Object Pattern

All web UI interactions MUST follow the Page Object pattern:

- MUST be stored in `/src/acceptance/drivers/web/pages`
- MUST extend `BasePage` class
- MUST encapsulate all page-specific selectors and interactions
- MUST provide high-level methods for page operations
- MUST handle low-level WebDriver interactions
- MUST implement proper wait strategies
- MUST use data-testid attributes for element selection
- Example: `/src/acceptance/drivers/web/pages/account_registration.page.ts`

---

## üîç Code Quality & Testing Standards

### Clean Code

- Follow SOLID
- Avoid code smells & duplication
- Handle errors cleanly
- Use meaningful names

### Testing Best Practices

- Follow AAA (Arrange-Act-Assert)
- Ensure: independent, repeatable, timely, self-validating tests

### Error Handling

- Implement timeouts and diagnostics
- Log and gracefully handle failures

---

## üß™ Test Data Management

### Builders

- Use Builder pattern
- Provide defaults and override options

### Cleanup

- Use teardown hooks
- Ensure graceful failure
- Log issues

### Isolation

- Ensure test data uniqueness
- Avoid external dependencies
- Support parallel execution

---

## ‚öôÔ∏è Configuration & Security

- Use `/src/config` for env-based config
- Store secrets securely (e.g., `process.env`)
- Validate configuration on startup

---

## üì¶ Shared Resources

### Utilities

- Store in `/src/shared`
- Reusable and documented
- No test-specific logic

### Base Classes

- Must be extensible and SOLID-compliant
- Provide clear responsibilities

---

## ‚úÖ Validation Checklist

All acceptance tests MUST:

1. Pass consistently in CI/CD
2. Be maintainable and isolated
3. Reflect business value
4. Follow the Four-Layer Model

---

## üìö References

- Dave Farley: Four-Layer Testing Model
- Clean Architecture & SOLID Principles
- Domain-Driven & Behavior-Driven Design
- Page Object Pattern (via Martin Fowler)
